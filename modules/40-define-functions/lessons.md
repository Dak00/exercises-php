## Создание (определение) функции

Пора научиться создавать собственные функции! Код, в котором создаётся функция, называется **определением функции**. Вот шаблон определения простой функции:

```php
<?php

function имяФункции()
{
    тело функции, т.е. код
}
```

Определение собственных функций значительно упрощает написание и поддержку программ. Функции позволяют объединять сложные (составные) операции в одну. Например, отправка письма на сайте - это достаточно сложный процесс, включающий в себя взаимодействие с внешними системами (интернет). Благодаря возможности определять функции, вся сложность может быть скрыта за простой функцией:

```php
<?php

namespace Some\Email\Package\send;

$email = 'support@hexlet.io';
$title = 'Помогите';
$body = 'Я написал историю успеха, как я могу получить скидку?';

// Один маленький вызов — и много логики внутри
send($email, $title, $body);
```

Создадим нашу первую функцию. Её задача вывести на экран следующий текст: _Today is: December 5_

```php
<?php

function showCurrentDay()
{
    $text = 'Today is: December 5';
    print_r($text);
}
```

В нашей функции только две строчки кода, но их может быть сколько угодно. Чтобы на 100% понять происходящее, обязательно сделайте следующее:

1. Зайдите на [https://repl.it/languages/php](https://repl.it/languages/php). Это онлайн-интерпретатор PHP.
2. В левой части введите код примера выше.
3. Скопируйте и запустите программу с помощью кнопки "RUN ▶".
4. Программа выполнится, но на экран ничего не выведется, потому что в программе есть только определение функции, но не запуск.
5. Чтобы запустить функцию, нужно **вызвать** её. Добавьте к программе вызов:

    ```php
    <?php

    function showCurrentDay()
    {
        $text = 'Today is: December 5';
        print_r($text);
    }

    // Вызов функции
    showCurrentDay();
    ```

6. Запустите программу снова и удостоверьтесь, что в правой части на экран вывелся ожидаемый текст.

Всё, что описывается внутри фигурных скобок `{}`, называется телом функции. Внутри тела можно описывать любой код. Считайте, что это маленькая самостоятельная программа, набор произвольных инструкций. Тело выполняется ровно в тот момент, когда запускается функция. Причём каждый вызов функции запускает тело независимо от других вызовов. Кстати, тело может быть пустым:

```php
<?php

// Минимальное определение функции, которая ничего не делает
function noop() {};

noop(); // вызов есть, а смысла нет
// Такая функция тоже бывает полезна,
// но это относится к продвинутым темам
```

Понятие «создать функцию» имеет много синонимов: «реализовать», «определить» и даже «заимплементить» (от слова implement). Все они встречаются в повседневной практике на работе.

!!  **Важное замечание!** В задачах, в которых нужно реализовать функцию, эту функцию вызывать не нужно. Вызывать функцию будут автоматизированные тесты, которые проверяют её работоспособность. Пример с вызовом выше показан только для того, чтобы вы понимали, как ваша функция будет использоваться.

## Передача одного аргумента

Функции без аргументов встречаются редко. Чаще функции принимают на вход данные, как-то их используют и выдают результат обратно. Сначала мы познакомимся с определением функций, принимающих на вход один аргумент. Посмотрите на определение ниже:

```php
<?php

function showCurrentDay($text)
{
    print_r("Today is: {$text}");
}

showCurrentDay('January 29'); // => "Today is: January 29"
```

Теперь понятно, зачем нужны были круглые скобки после имени функции: в них *можно* указать аргументы (или, что тоже самое, параметры). Технически, параметры функции всегда являются переменными, а не константами. Но лучше относиться к ним как к константам. Заметьте: мы не определяем переменную `$text`, но используем её в теле функции. PHP работает так: переменная сама создаётся при вызове, и указанное значение (в нашем примере — `'January 29'`) записывается в эту переменную. Аргументы можно называть как угодно, их имена имеют смысл исключительно в теле функции. Например, если изменить имя аргумента, то поведение функции не изменится:

```php
<?php

function showCurrentDate($lala)
{
    print_r("Today is: {$lala}");
}

// Значение аргумента можно присвоить переменной
$date = 'January 29';
showCurrentDate($date);
```

Новички иногда пытаются сделать примерно такое определение функции:

```php
<?php

function showCurrentDate('Today is: December 5')
{
    // какой-нибудь код
}
```

Запустить такой код не получится — он содержит синтаксическую ошибку. Вместо переменной в аргументе написана строка, то есть значение.

*Аргумент должен быть переменной*, иначе он не сможет быть аргументом, то есть чем-то, что *принимает значение при вызове*.

Если же вам нужна какая-то информация в функции, и вы заранее знаете, какая именно, то аргумент для этого не нужен: ведь мы уже умеем сохранять значения для последующего использования —  достаточно создать переменную в самом теле:

```php
<?php

function showCurrentDate()
{
    $text = 'Today is: December 5';
    // какой-нибудь код
}
```

## Передача нескольких аргументов

  Аргументов может быть несколько. В таком случае в определении функции мы делаем то же самое, что в вызове: просто указываем аргументы через запятую.

  Полный пример определения функции с несколькими аргументами и её вызова:

  ```php
  <?php

  function showCurrentDay($month, $day)
  {
      print_r("Today is: {$month} {$day}");
  }

  showCurrentDay('January', '29');
  ```

  <pre class='hexlet-basics-output'>Today is: January 29</pre>

  Главное — помнить про порядок: в каком порядке аргументы стоят при определении функции, в таком же порядке они должны передаваться при вызове.

  В PHP, как и в большинистве языков, при вызове функции нужно обязательно передать столько же аргументов, сколько было указано при её определении. Иначе программа выдаст ошибку `Uncaught ArgumentCountError`.

  Обратите внимание: после определения функции (после закрывающей фигурной скобки) мы не ставим `;`.

  Символ `;` ставится в конце выражений. **Определение функции — не выражение, а инструкция** (указание интерпретатору). Соответственно, мы не можем его использовать в составе других выражений, и ему не нужна `;` в конце.

instructions: |

  Сэм составляет множество карт, и ему часто нужно выводить на экран повторяющиеся символы для визуализации маршрутов. Например, так Сэм иллюстрирует узкие дороги между городами:

  ```
  Meereen =-=-=-=- Myr
  ```

  А так иллюстрирует широкие трассы:

  ```
  Vaes Dothrak ======== Vahar
  ```

  В [документации PHP](https://php.net/manual/ru/function.str-repeat.php) он нашёл функцию `str_repeat()`. Она принимает два аргумента: строку и число, и возвращает повторяющуюся строку. Вот как он использует её:

  ```php
  <?php

  print_r(str_repeat("=-", 4));
  ```

  <pre class='hexlet-basics-output'>=-=-=-=-</pre>

  Сэм не очень доволен. Неудобно вызывать сотни раз `str_repeat()` внутри вызова `print_r()`.

  Напишите для Сэма функцию `printSeq()`, которая сама выводит на экран получившиеся повторения. Она принимает два аргумента — строку и число, и выводит повторяющуюся строку на экран. Для генерации строки используйте `str_repeat()`.

  Вот пример того, как Сэм будет использовать написанную вами `printSeq()`:

  ```php
  <?php

  printSeq("=-", 4);
  ```

  <pre class='hexlet-basics-output'>=-=-=-=-</pre>

tips: []
name: Возврат значений
theory: |

  В модуле «Вызов функций» мы в основном работали с функциями, которые возвращают результат, а не выводят его на экран. Честно говоря, вывод на экран — фактически обучающий элемент. В реальном коде на экран никто ничего не выводит (за исключением утилит командной строки). Функции возвращают данные, которые потребляются другими функциями.

  Научиться писать функции, которые возвращают информацию — первый шаг на пути к построению по-настоящему полезных программ.

  Начнем с тривиального примера: создадим и вызовем функцию, которая принимает два числа и возвращает первое число минус второе. Назовём её `sub`, от англ. "subtract" — «вычесть»:

  ```php
  <?php

  function sub($a, $b)
  {
      $result = $a - $b;
      return $result;
  }

  $result = sub(10, 7);
  print_r($result); // => 3
  ```

  Возврат задаётся специальной инструкцией `return`. Cправа от `return` помещается выражение. Любое выражение. То есть, мы можем делать вычисления сразу после `return` без создания переменной `$result`:

  ```php
  <?php

  function sub($a, $b)
  {
      // Сначала вычисляется выражение справа от `return`,
      // затем получившееся значение возвращается
      return $a - $b;
  }

  print_r(sub(2018, 1975)); // => 43
  ```

  _Обратите внимание: мы знаем, что **вызов функции — выражение**, поэтому мы передали вызов одной функции в вызов другой функции — `print_r(sub(2018, 1975))`._

  После исполнения функции возвращенный результат «встаёт» на место вызова:

  ![](https://i.imgur.com/m6hwc25.png)

  ---

  Интерпретатор, встречая `return`, останавливает дальнейшее выполнение функции и возвращает указанное справа значение в то место, где была вызвана функция.

  Посмотрите на эту функцию:

  ```php
  <?php

  function foo()
  {
      return 7;
      return 10;
  }

  print_r(foo());
  ```

  Что выведется на экран?

  Правильный ответ: `7`. Функция всегда будет возвращать только число `7`, так как интерпретатор, наткнувшись на первый `return`, остановит выполнение функции. Строчка кода `return 10;` никогда не выполнится.


instructions: |

  Сэм создаёт генеалогические деревья разных семей. Ему постоянно приходится рассчитывать количество места, занимаемое именами родителей на экране.

  Создайте функцию `getParentNamesTotalLength()` для Сэма. Она должна принимать один аргумент — имя ребёнка, и возвращать количество символов в именах матери и отца суммарно. Функция не должна выводить ничего на экран, только возвращать число.

  Пример вызова:

  ```php
  <?php

  getParentNamesTotalLength('Daenerys Targaryen'); // 35
  ```

  Для реализации используйте уже существующие функции `getParentFor()` и `strlen()`:

  * Получение имени матери `getParentFor($child, 'mother')`, где `$child` — имя ребёнка.
  * Получение имени отца `getParentFor($child, 'father')`, где `$child` — имя ребёнка
  * Получение длины строки: `strlen($str)`, где `$str` — строка

  Вам не нужно вызывать свою функцию, только определить её.

tips: []
---

name: Возврат по умолчанию
theory: |

  Рассмотрим немного модифицированную функцию из предыдущего урока:

  ```php
  <?php

  function sub($a, $b)
  {
      // Полученный результат никак не используется
      // и не возвращается наружу
      $output = $a - $b;
  }

  $result = sub(10, 7);
  print_r($result);
  var_dump($result); // => NULL
  ```

  Несмотря на отсутствие `return` внутри функции `sub()`, в переменную `$result` будет *что-то* записано. Это специальный тип данных `null`. Он используется в ситуациях, когда значение чего-либо *не определено*. У этого типа данных есть единственное значение – `NULL`. Это специальное значение невозможно вывести на экран привычной функцией `print_r()`. Чтобы увидеть `null`, нужно воспользоваться другой функцией – `var_dump()`.

  Вызов функции – выражение, а выражения **всегда** возвращают результат своего выполнения. Это стандартное поведение функций в PHP, оно существует не просто так.

  Но, конечно, смысла в этой программе нет — функция сейчас не делает ничего полезного. Добавим `return` и вернём `$output`:

  ```php
  <?php

  function sub($a, $b)
  {
      $output = $a - $b;
      return $output;
  }

  $result = sub(10, 7);
  print_r($result); // => 3
  ```

  Теперь всё работает как надо.

  Забыть инструкцию `return` — частая ошибка новичка. Мы в обучении каждый день сталкиваемся с просьбами о помощи типа «функция правильная, но почему-то не работает». И почти всегда оказывается, что забыт `return`.

  С другой стороны, если написать инструкцию `return` без указания выражения после него, то наружу вернется все тот же `NULL`. Кажется, что подобный возврат не имеет смысла, но это не так. `return` без выражения нередко используют для прерывания вычислений. Подробнее эта тема раскрывается в модуле, посвященному условным конструкциям.

  Кстати, вы можете сами написать `return null` в теле функции. Функция будет возвращать `NULL`, как если бы в ней не было `return`.

instructions: |

  Это немного странное задание, но для тренировки будет полезным. Реализуйте функцию `getNull()`, которая просто возвращает `null` и больше ничего не делает.

  Вам не нужно вызывать свою функцию, только определить её.

tips: []
name: Параметры по умолчанию
theory: |

  Напомним, что аргумент может быть **необязательным**. У такого аргумента есть **значение по умолчанию**.

  Например, функция `getParentFor()`, которую вы использовали в некоторых упражнениях, принимает имя ребёнка первым аргументом, а вторым — строку `mother` или `father`. Второй аргумент — необязательный, и если не указывать его, то автоматически по умолчанию будет использоваться `mother`.

  Эти два вызова равнозначны:

  ```php
  <?php

  getParentFor('Jon Snow');
  getParentFor('Jon Snow', 'mother');
  ```

  Каким образом там сделаны аргументы по умолчанию? Давайте заглянем в определение этой функции:

  ```php
  <?php

  function getParentFor($child, $parent = 'mother')
  {
      // какой-то код
  }
  ```

  Первый аргумент указан привычно — просто название переменной. Это делает аргумент *обязательным*.

  Второй аргумент указан со значением в формате `$аргумент = какое_то_значение`. Точно так же, как при создании переменной. Этот фрагмент `= какое_то_значение` делает аргумент *необязательным*, и задаёт ему *значение по умолчанию*.

  Аргументов по умолчанию может быть любое количество, но все они должны быть в конце списка аргументов. То есть такие строчки кода синтаксически некорректны:

  - `function getParentFor($childName = 'Jon', $who)`
  - `function calculate($a, $b = 90, $c)`
  - `function getPrices($code = 4161, $quantity, $place)`

instructions: |

  Реализуйте функцию `getCustomParentFor()`, которая принимает два аргумента:

  1. Строку — имя ребёнка.
  2. Строку с указанием родителя. Этот аргумент должен по умолчанию быть `'father'`.

  Функция должна возвращать имя соответствующего родителя.

  Пример вызова:

  ```php
  <?php

  getCustomParentFor('Cersei Lannister'); // Tywin Lannister
  ```

  Такой вызов вернёт имя отца.

  - Используйте готовую функцию `getParentFor()` внутри своей функции.
  - Не нужно вызывать свою функцию `getCustomParentFor()`, только определить её.
---

name: Именование
theory: |

  Стиль именования функций в PHP такой же, как и стиль именования переменных: _lowerCamelCase_. Но при выборе самих слов есть важное отличие.

  **Функция — действие**, вызов функции всегда подобен указанию «сходи», «возьми», «напечатай», «положи» и так далее. Вспомните, какие функции были в предыдущих уроках:

  - `showDate` («показать дату»)
  - `sub` (subtract — «вычесть»)
  - `print_r` («напечатать»)
  - `round` («округлить»)
  - `gettype` («получить тип»)

  **Переменная — сущность**, поэтому мы используем существительные:

  - `$child`
  - `$result`
  - `$euros`

  Берите на вооружение следующую структуру: функция — глагол, переменная — существительное.

  В уроке про переменные мы просили вас придумать название переменной и записать в блокноте или отправить себе на почту. Найдите это название и посмотрите на него свежим взглядом: оно понятное? Описывает суть однозначно или требует вникания?

  Жизнь программиста наполнена такими моментами: открыть старый код и попытаться понять его. Будьте добры к будущему себе и к коллегам, давайте переменным и функциям понятные названия.

instructions: |

  В PHP из языка Си перекочевала интересная функция `sprintf()`. Она создаёт строку на основе шаблона и данных.

  ```php
  <?php

  $result = sprintf('Today is %s %d', 'February', 8);
  print_r($result);
  ```

  <pre class='hexlet-basics-output'>Today is February 8</pre>

  Первый аргумент в `sprintf` — строка-шаблон, в которой кроме самого текста могут присутствовать специальные заполнители. Это «заглушки» для информации, которая передаётся следующими аргументами. `%s` означает «заглушка для строки», `%d` — для числа. Поэтому следующие два аргумента в нашем примере — строка и число.

  Порядок и тип значений должны совпадать с порядком и типом заглушек.

  При выводе дат иногда требуется фиксировать количество цифр, скажем, всегда писать нули перед числом если число меньше 10. `sprintf` позволяет решить эту задачу:

  ```php
  <?php

  $result = sprintf('Today is %s %02d', 'February', 8);
  print_r($result);
  ```

  <pre class='hexlet-basics-output'>Today is February 08</pre>

  `%02d` — сделать две цифры и заполнить нулями оставшееся пространство. `%03d` — три цифры, и так далее:

  ```php
  <?php

  $result = sprintf('Today is %s %04d', 'February', 8);
  print_r($result);
  ```

  <pre class='hexlet-basics-output'>Today is February 0008</pre>

  Реализуйте функцию `getFormattedBirthday()`, которая принимает на вход три параметра: день, месяц и год рождения, а возвращает их строкой в отформатированном виде, например: `20-02-1953`.

  ```php
  <?php

  $result = getFormattedBirthday(20, 2, 1953);
  print_r($result);
  ```

  <pre class='hexlet-basics-output'>20-02-1953</pre>

  День и месяц нужно форматировать так, чтобы при необходимости добавлялся `0` слева. Например, если в качестве месяца пришла цифра `7`, то в выходной строке она должна быть представлена как `07`.

tips:
  - |
    [Статья про именование в программировании](https://ru.hexlet.io/blog/posts/naming-in-programming)
  - |
    [Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)
---

name: Окружение
theory: |

  Какое значение окажется внутри переменной `$result` после выполнения кода?

  ```php
  <?php

  $age = 5;

  function generate()
  {
      return $age + 3;
  }

  $result = generate();
  ```

  Правильный ответ: код упадёт с ошибкой. Потому что внутри функции нет переменной с именем `$age`, но функция пытается её использовать.

  Функция изолирована от внешних переменных. Все переменные, определенные снаружи функции, никак не связаны с переменными, определенными внутри. В теле функции находится программа, изолированная от внешней среды (внешнего окружения).

  Рассмотрим другой пример:

  ```php
  <?php

  $age = 5;

  function changeAge()
  {
      $age = 8;
  }

  changeAge();

  print_r($age); // => 5
  ```

  Переменная, созданная внутри функции `changeAge()`, никак не влияет на внешнюю переменную `$age`, поэтому после вызова функции значение внешней `$age` не изменилось и осталось `5`.

instructions: |

  Это задание не связано напрямую с уроком, это просто ещё одно полезное упражнение по работе с функциями.

  Напишите функцию `getAgeDifference()`, которая принимает два года рождения и возвращает строку с разницей в возрасте в виде `The age difference is 11`. Например:

    ```php
    <?php

    $actual = getAgeDifference(2001, 2018);
    print_r($actual); // => The age difference is 17

    $actual2 = getAgeDifference(2020, 2002);
    print_r($actual2); // => The age difference is 18
    ```

tips:
  - |
    Напомним, что в PHP есть функция `abs()`, которая возвращает модуль переданного числа: например, `abs(-12)` вернёт `12`.




---

name: Чтение документации
theory: |

  Умение читать документацию — один из важнейших навыков любого разработчика.

  _Несмотря на наличие перевода, я рекомендую учиться пользоваться англоязычной документацией. Библиотеки, которые сотнями используются в реальных проектах, почти всегда имеют только англоязычное описание._

  Основной раздел, к которому программисты возвращаются постоянно — справочник функций языка. Во-первых, этих функций много и невозможно запомнить всё. Во-вторых, в PHP особенно остро стоит проблема несогласованности параметров и возвращаемых значений функций. Поэтому постоянно приходится вспоминать их порядок.

  Для описания функций используется собственная нотация (свой собственный синтаксис). Она немного напоминает сам PHP, но всё же отличается от него, другими словами — это не код на PHP, а только лишь описание сигнатуры функции. Рассмотрим функцию `round()`, которая округляет число:

  ```
  round ( float $val [, int $precision = 0 [, int $mode = PHP_ROUND_HALF_UP ]] ) : float
  ```

  Задача этого формата — наглядно показать типы, количество и значения по умолчанию входящих параметров, а также тип выходного параметра. Последний всегда стоит в самой правой позиции, прямо после знака двоеточия. В данном случае тип возвращаемого значения `float`.

  Перечисление параметров идет через запятую в скобках после названия функции. Перед каждым именем параметра стоит его тип. Например, тип параметра `$val` — это `float`. Значение по умолчанию задается как присваивание, например `$precision` по умолчанию равно нулю.

  Квадратные скобки _[]_ показывают необязательные параметры функции, а запятые отделяют их друг от друга. Для функции выше это `$precision` и `$mode`. `$mode`, в свою очередь, по умолчанию равен значению константы `PHP_ROUND_HALF_UP`. Если какой-либо параметр равен значению константы, значит в документации этой функции есть перечисление и описание всех возможных констант, которые могут быть использованы как значение этого параметра.

  Основываясь на сказанном выше, мы можем вызвать функцию следующим образом:

  ```php
  <?php

  round(5.3); // 5.0
  round(8.333, 1); // 8.3
  round(8.333, 2, PHP_ROUND_HALF_UP); // 8.33
  ```

instructions: |

  Реализуйте функцию `getAge()`, которая округляет возраст в нижнюю сторону. То есть если человеку десять с половиной лет, то функция должна вернуть `10`.

  Используйте для этого стандартную функцию `round()` и специальное значение параметра `$mode`, которое приводит к округлению в нижнюю сторону.

  ```php
  <?php

  getAge(10);  // 10.0
  getAge(9.1); // 9.0
  getAge(8.5); // 8.0
  ```

tips:
  - |
    [Документация PHP на русском языке](https://php.net/manual/ru/)
  - |
    [Справочник функций](https://php.net/manual/ru/funcref.php)
  - |
    [Функция round()](https://php.net/manual/ru/function.round.php)
